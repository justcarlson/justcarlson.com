---
phase: 21-avatar-fallback
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - public/avatar-fallback.webp
  - src/pages/index.astro
  - tests/image-fallback.spec.ts
autonomous: false

user_setup:
  - service: local-asset
    why: "Fallback avatar image (same photo as Gravatar)"
    human_action:
      - task: "Provide source avatar image"
        instruction: "Place your avatar source image (JPG or PNG, same photo used on Gravatar) in the project root as 'avatar-source.jpg' or 'avatar-source.png'. Claude will convert it to WebP."

must_haves:
  truths:
    - "Homepage avatar uses Vercel Image Optimization proxy URL (/_vercel/image?url=...)"
    - "When proxy fails, local fallback image displays (no broken image icon)"
    - "No layout shift when fallback triggers"
    - "Avatar renders correctly in both light and dark themes"
  artifacts:
    - path: "public/avatar-fallback.webp"
      provides: "Local fallback avatar image"
      contains: "WebP image file"
    - path: "src/pages/index.astro"
      provides: "Avatar with proxy URL and onerror handler"
      contains: "/_vercel/image"
    - path: "tests/image-fallback.spec.ts"
      provides: "Avatar fallback test"
      contains: "avatar.*fallback"
  key_links:
    - from: "src/pages/index.astro"
      to: "/_vercel/image"
      via: "Vercel proxy URL in img src"
      pattern: "_vercel/image\\?url="
    - from: "src/pages/index.astro"
      to: "/avatar-fallback.webp"
      via: "onerror handler"
      pattern: "onerror.*avatar-fallback"
---

<objective>
Implement resilient avatar loading with Vercel Image Optimization proxy and local fallback.

Purpose: Avatar displays reliably regardless of Gravatar/proxy availability, eliminating broken image icons when external services are blocked.

Output: Homepage avatar uses proxy URL with onerror fallback, plus Playwright tests verifying fallback behavior.
</objective>

<execution_context>
@/home/jc/.claude/get-shit-done/workflows/execute-plan.md
@/home/jc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-avatar-fallback/21-CONTEXT.md
@.planning/phases/21-avatar-fallback/21-RESEARCH.md
@src/pages/index.astro
@tests/image-fallback.spec.ts
</context>

<tasks>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 1: Provide avatar source image</name>
  <action>
    Place your avatar source image in the project root. Claude will convert it to WebP for the fallback.
  </action>
  <instructions>
    1. Export your avatar photo (the same one used on Gravatar)
    2. Save as `avatar-source.jpg` or `avatar-source.png` in the project root
    3. Image should be at least 160x160 pixels (256x256 recommended for retina)
    4. Type "done" when file is in place
  </instructions>
  <resume-signal>Type "done" when avatar-source.jpg/png is in project root</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Create fallback image and update avatar component</name>
  <files>public/avatar-fallback.webp, src/pages/index.astro</files>
  <action>
    1. Convert the source image to WebP using sharp (already in devDependencies):
       ```bash
       node -e "require('sharp')('avatar-source.jpg').resize(256, 256).webp({quality: 80}).toFile('public/avatar-fallback.webp')"
       ```
       (Adjust filename if user provided .png)

    2. Update `src/pages/index.astro` avatar implementation:
       - Build Vercel proxy URL with proper encoding
       - Add onerror handler with `this.onerror=null` pattern
       - Add explicit width/height attributes (160x160)
       - Add loading="eager" (above fold content)

    Implementation pattern from RESEARCH.md:
    ```astro
    ---
    // In frontmatter
    const gravatarUrl = "https://gravatar.com/avatar/ef133a0cc6308305d254916b70332b1a?s=400";
    const proxyUrl = `/_vercel/image?url=${encodeURIComponent(gravatarUrl)}&w=256&q=75`;
    const fallbackUrl = "/avatar-fallback.webp";
    ---

    <img
      src={proxyUrl}
      onerror={`this.onerror=null; this.src='${fallbackUrl}';`}
      alt={SITE.author}
      width="160"
      height="160"
      loading="eager"
      class="w-40 h-40 rounded-full object-cover flex-shrink-0 transition-all duration-300 group-hover:scale-105 group-hover:shadow-xl"
    />
    ```

    3. Clean up source image after conversion:
       ```bash
       rm avatar-source.jpg  # or .png
       ```
  </action>
  <verify>
    1. `ls -la public/avatar-fallback.webp` confirms file exists
    2. `grep -q "_vercel/image" src/pages/index.astro` confirms proxy URL
    3. `grep -q "onerror" src/pages/index.astro` confirms fallback handler
    4. `npm run build` succeeds
    5. `npm run dev` shows avatar correctly on homepage
  </verify>
  <done>
    - public/avatar-fallback.webp exists (WebP format, ~256x256)
    - index.astro uses Vercel proxy URL with encoded Gravatar URL
    - index.astro has onerror handler pointing to local fallback
    - Avatar displays correctly in dev server
  </done>
</task>

<task type="auto">
  <name>Task 3: Add avatar-specific fallback test</name>
  <files>tests/image-fallback.spec.ts</files>
  <action>
    Add a new test case to tests/image-fallback.spec.ts that specifically tests avatar fallback behavior:

    ```typescript
    test("avatar falls back to local image when proxy blocked", async ({ page }) => {
      // Block Vercel image optimization proxy
      await page.route("**/_vercel/image**", (route) => route.abort("blockedbyclient"));

      // Also block direct Gravatar (belt and suspenders)
      await page.route("**/gravatar.com/**", (route) => route.abort("blockedbyclient"));

      await page.goto("/");
      await page.waitForLoadState("networkidle");

      // Find the avatar image (in the hero section, links to /about)
      const avatar = page.locator('a[href="/about"] img');
      await expect(avatar).toBeVisible();

      // Avatar should have loaded the fallback (naturalWidth > 0)
      const naturalWidth = await avatar.evaluate((el: HTMLImageElement) => el.naturalWidth);
      expect(naturalWidth).toBeGreaterThan(0);

      // Verify it's using the fallback URL
      const src = await avatar.getAttribute("src");
      expect(src).toContain("avatar-fallback.webp");
    });
    ```

    Place this test inside the existing `test.describe("Image fallback behavior", ...)` block.
  </action>
  <verify>
    1. `npx playwright test tests/image-fallback.spec.ts` passes all tests
    2. New test specifically validates avatar fallback
  </verify>
  <done>
    - New test "avatar falls back to local image when proxy blocked" exists
    - Test passes when run with Playwright
    - All existing tests still pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` succeeds
2. `npx playwright test tests/image-fallback.spec.ts` passes (including new avatar test)
3. Manual verification: Run dev server, open DevTools Network tab, block requests to `_vercel/image` and `gravatar.com`, refresh - avatar should show fallback without broken image icon
</verification>

<success_criteria>
- Homepage avatar uses `/_vercel/image?url=...` proxy URL
- onerror handler swaps to `/avatar-fallback.webp` on failure
- No broken image icons when Gravatar/proxy unavailable
- No layout shift (explicit width/height attributes)
- Playwright test verifies fallback behavior
- Build succeeds with new implementation
</success_criteria>

<output>
After completion, create `.planning/phases/21-avatar-fallback/21-01-SUMMARY.md`
</output>
