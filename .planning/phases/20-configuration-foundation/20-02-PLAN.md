---
phase: 20-configuration-foundation
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - package.json
  - playwright.config.ts
  - tests/image-fallback.spec.ts
autonomous: true

must_haves:
  truths:
    - "Playwright is installed and runnable"
    - "Test can block external images via route interception"
    - "Test verifies no broken image icons when images blocked"
    - "Test can run against local dev server"
  artifacts:
    - path: "package.json"
      provides: "@playwright/test devDependency"
      contains: "@playwright/test"
    - path: "playwright.config.ts"
      provides: "Playwright configuration"
      contains: "defineConfig"
    - path: "tests/image-fallback.spec.ts"
      provides: "Image blocking tests"
      contains: "page.route"
  key_links:
    - from: "tests/image-fallback.spec.ts"
      to: "page.route API"
      via: "Playwright network interception"
      pattern: "page\\.route.*abort"
    - from: "playwright.config.ts"
      to: "tests/ directory"
      via: "testDir config"
      pattern: "testDir.*tests"
---

<objective>
Set up Playwright testing infrastructure for image blocking verification.

Purpose: Enable automated testing of graceful fallback behavior when external images are blocked. Tests intercept network requests to simulate blocked images and verify the page renders without broken image icons.

Output: Playwright installed, configured, and initial image blocking test created.
</objective>

<execution_context>
@/home/jc/.claude/get-shit-done/workflows/execute-plan.md
@/home/jc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-configuration-foundation/20-CONTEXT.md
@.planning/phases/20-configuration-foundation/20-RESEARCH.md
@.planning/phases/20-configuration-foundation/20-01-SUMMARY.md

@package.json
@src/pages/index.astro
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Playwright and create configuration</name>
  <files>package.json, playwright.config.ts</files>
  <action>
1. Install Playwright as devDependency:
```bash
npm install -D @playwright/test
npx playwright install chromium
```

2. Create `playwright.config.ts` at project root:
```typescript
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:4321',
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:4321',
    reuseExistingServer: !process.env.CI,
    timeout: 120 * 1000,
  },
});
```

Key settings:
- `testDir: './tests'` - tests live in /tests directory
- `baseURL: 'http://localhost:4321'` - Astro dev server port
- `webServer.command: 'npm run dev'` - auto-starts dev server
- `webServer.reuseExistingServer` - reuses running server locally
- Only chromium project (no need for cross-browser for this use case)

3. Add test script to package.json scripts:
```json
"test": "playwright test",
"test:ui": "playwright test --ui"
```
  </action>
  <verify>
1. `npm list @playwright/test` shows package installed
2. `test -f playwright.config.ts && echo "exists"` returns "exists"
3. `grep '"test":' package.json` shows test script defined
  </verify>
  <done>
Playwright installed, configured with webServer for Astro dev, and test scripts added to package.json
  </done>
</task>

<task type="auto">
  <name>Task 2: Create image blocking test</name>
  <files>tests/image-fallback.spec.ts</files>
  <action>
Create `tests/image-fallback.spec.ts`:

```typescript
import { test, expect } from '@playwright/test';

test.describe('Image fallback behavior', () => {
  test('shows fallback when external images blocked', async ({ page }) => {
    // Collect console errors for later verification
    const consoleErrors: string[] = [];
    page.on('console', msg => {
      if (msg.type() === 'error') {
        consoleErrors.push(msg.text());
      }
    });

    // CRITICAL: Set up route interception BEFORE navigation
    // This prevents race conditions where images load before blocking kicks in
    await page.route('**/*.{png,jpg,jpeg,gif,webp,avif}', route => {
      const url = route.request().url();
      // Block external images only (not local assets)
      if (!url.includes('localhost') && !url.includes('127.0.0.1')) {
        return route.abort('blockedbyclient');
      }
      return route.continue();
    });

    // Also block the specific external domains we're testing
    await page.route('**/gravatar.com/**', route => route.abort('blockedbyclient'));
    await page.route('**/ghchart.rshah.org/**', route => route.abort('blockedbyclient'));

    await page.goto('/');

    // Wait for page to fully load
    await page.waitForLoadState('networkidle');

    // Verify page renders (basic smoke test)
    await expect(page.locator('h1')).toBeVisible();

    // Check for broken image icons by looking for images with naturalWidth of 0
    // BUT we need to account for images that are intentionally hidden or use CSS fallback
    const images = page.locator('img');
    const imageCount = await images.count();

    for (let i = 0; i < imageCount; i++) {
      const img = images.nth(i);
      const isVisible = await img.isVisible();

      if (isVisible) {
        // If image is visible, check it's either:
        // 1. Loaded successfully (naturalWidth > 0), OR
        // 2. Hidden via CSS (display: none or visibility: hidden), OR
        // 3. Has a fallback parent with background
        const naturalWidth = await img.evaluate((el: HTMLImageElement) => el.naturalWidth);
        const isHidden = await img.evaluate((el: HTMLImageElement) => {
          const style = window.getComputedStyle(el);
          return style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0';
        });

        // If naturalWidth is 0 and not hidden, the parent should have fallback styling
        if (naturalWidth === 0 && !isHidden) {
          const parent = img.locator('..');
          // Parent should exist (test won't fail if fallback CSS not applied yet,
          // but will fail if there's a broken image icon visible)
          await expect(parent).toBeVisible();
        }
      }
    }

    // Filter out expected blocked resource messages
    const unexpectedErrors = consoleErrors.filter(
      e => !e.includes('net::ERR_FAILED') &&
           !e.includes('net::ERR_BLOCKED_BY_CLIENT') &&
           !e.includes('blocked')
    );

    // There should be no unexpected console errors
    expect(unexpectedErrors).toHaveLength(0);
  });

  test('page loads without external images', async ({ page }) => {
    // Block ALL external requests to simulate strict firewall
    await page.route('**/*', route => {
      const url = route.request().url();
      if (url.includes('localhost') || url.includes('127.0.0.1')) {
        return route.continue();
      }
      // Block everything external
      return route.abort('blockedbyclient');
    });

    await page.goto('/');
    await page.waitForLoadState('domcontentloaded');

    // Page should still render main content
    await expect(page.locator('h1')).toBeVisible();
    await expect(page.locator('main')).toBeVisible();
  });
});
```

Key patterns:
1. Route interception set up BEFORE `page.goto()` (prevents race conditions)
2. Console error collection for silent failure verification
3. `blockedbyclient` abort reason for clarity in logs
4. Two tests: specific image blocking + total external blocking
5. Comments explain WHY each check exists
  </action>
  <verify>
1. `test -f tests/image-fallback.spec.ts && echo "exists"` returns "exists"
2. `grep -c "page.route" tests/image-fallback.spec.ts` returns at least 2
3. `grep -c "blockedbyclient" tests/image-fallback.spec.ts` returns at least 2
4. `npm run test -- --list` shows the tests are discovered
  </verify>
  <done>
Image blocking test file exists with route interception, console error collection, and both specific and total blocking scenarios
  </done>
</task>

</tasks>

<verification>
1. Playwright works: `npm run test -- --list` shows discovered tests
2. Tests can run: `npm run test` executes (may have expected failures if CSS not wired yet)
3. Route blocking works: Tests use `page.route` API correctly
4. Dev server integration: Playwright starts Astro dev server automatically
</verification>

<success_criteria>
- @playwright/test is in devDependencies
- playwright.config.ts exists with Astro webServer configuration
- tests/image-fallback.spec.ts exists with image blocking tests
- `npm run test` script is defined in package.json
- Tests use route interception to block external images
- Tests check for console errors (silent failure verification)
</success_criteria>

<output>
After completion, create `.planning/phases/20-configuration-foundation/20-02-SUMMARY.md`
</output>
